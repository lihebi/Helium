#+TITLE: Helium Cache Design


#+BEGIN_EXAMPLE
~/.helium.d
|-- cache
    |-- _home_hebi_benchmark_projblue
        |-- src
        |-- snippet.db
        |-- code
            |-- 1.txt
            |-- 2.txt
        |-- tags
        |-- tokens.db
    |-- _home_hebi_benchmark_projred
|-- generate
    |-- UUID-DSFJ837-FJ839J-JI783AC
        |-- sel.txt
        |-- 
#+END_EXAMPLE

* Token Selection
The line and column number is based on the pre-processed file.

The token should be represented as range of source code.  For each
cache, there should be one token file. Every token should have a
unique ID.

| id | kind | file | line | col | end_line | end_col |
|----+------+------+------+-----+----------+---------|
|  0 | ID   | a.c  |    3 |   8 |        3 |      10 |
|  1 | Expr | b.c  |      |     |          |         |
|  2 | Decl | b.c  |      |     |          |         |

Distribution file

| id | kind      | Name | file | line | col | end_line | end_col |
|----+-----------+------+------+------+-----+----------+---------|
|  0 | procedure | foo  | a.c  |    3 |   1 |        8 |       2 |
|  1 | if        | NA   | a.c  |    5 |   2 |        7 |       0 |
|  2 | switch    |      | b.c  |      |     |          |         |
|  3 | loop      |      |      |      |     |          |         |

The selection file should be a list of IDs.
We need  to control
1. number of tokens
2. distribution of tokens: this using the token ID and the distribution file

** A simple approach
Generate ID for leaf nodes of AST. 
Print the AST, and ask for the selection.

In this case, the table is different: there'll be no line number staffs. So the table is not necessary.
The token database will contains the following:

| id | kind | file |
|----+------+------|
|  1 | ID   |      |
|  2 | ID   |      |
|  3 | Expr |      |

| distID | kind     | name | file |
|--------+----------+------+------|
|      1 | function |      |      |
|      2 | if       |      |      |

| distID | id |
|--------+----|
|      1 |  1 |
|        |  2 |
|        |  3 |
|        |  4 |
|      2 |  1 |
|        |  5 |


** Non-DB approach
OK! I got the idea.

*** DONE TokenNode
    CLOSED: [2017-03-24 Fri 03:20]
I'll have a special kind of AST Node called =TokenNode= inherit from
=ASTNodeBase=.  Each type of node will be able to get the token
node. For example, =IfStmt= will have a method called
- getIfTokenNode()
- getElseTokenNode()
- getParenTokenNode()


*** DONE TokenVisitor
    CLOSED: [2017-03-24 Fri 04:00]
I'll also implement a visitor called =TokenVisitor= that visitor all
the tokens of AST, and assign the IDs for each of them.


*** TODO SourceRange
To get the location, I'll add =SourceRange= class and add instances to
each of the AST Nodes (including the =TokenNode=).

The process is as follows:
- TokenVisitor is called, and assign IDs for all tokens
- Build a map for ID <-> SourceRange

*** TODO Test Selection Process
The selection process:
- for test, I list a list of source location
- helium read the location and map to the IDs. Using the IDs, it then map to the AST nodes
*** TODO GrammarPatcher
- I'll have another visitor called GrammarPatcher that, well this is
  tricky, goes from bottom to top of AST.
  - The input is the selection.
  - It can get the levels using the level-visitor.
  - Starting from the lowest level, get the parent, get its children
    in selection, and visit the parent node (not considering lazy
    evaluation for now). Put the parent into selection, and continue.

*** TODO random selection of distribution
- for random generate of selection with consideration of distribution

*** TODO Generator
Another visitor, the Generator, visit each node and output program. This is also very tricky:
- If I use SrcML's XML structure to generate, it is hard to "remove" something
- If I create string, many things are not modeled such as parenthesis.

I'll go with /hybrid/ method: use srcml for most of the part, and fine
tune to create string for the part that is omitted, e.g. the Inc expr
of forstmt.


* Cache
process the file or project, and create snippet database for it. The
result will be in =~/.helium.d/cache/XXX= where =XXX= is named by the
absolute path of proj or file with slashes replaced by
underline. E.g. =/path/to/file= would become =_path_to_file=. Inside
this folder, there will be a =index.db= and =code/= folder containing
=xx.txt=

The tree looks like this:


When running helium, first check if this folder exist. If yes,
continue. Otherwise prompt for creating it. When creating this, first
check if it exists, if yes, prompt for replacing or not =y/N=.

* Snippet DB
** snippet
This table corresponds to the snippet code, one piece of code per entry.

| Column Name | Type    | Size | PKey          | Null | Remarks |
|-------------+---------+------+---------------+------+---------|
| ID          | INT     |      | PRIMARY KEY 1 |      |         |
| filename    | VARCHAR |  500 |               |      |         |
| linum       | INT     |      |               |      |         |


** signature
A snippet might have many signature:
- a structure name
- a typedef
- members of an enumerator

| Column Name | Type    | Size | PKey          | Null | Remarks |
|-------------+---------+------+---------------+------+---------|
| ID          | INT     |      | PRIMARY KEY 1 |      |         |
| keyword     | VARCHAR |  100 |               |      |         |
| kind        | VARCHAR |    1 |               |      |         |
| snippet_id  | int     |      |               |      |         |

** dependence
A snippet depends upon another
| Column Name     | Type | Size | PKey          | Null | Remarks |
|-----------------+------+------+---------------+------+---------|
| ID              | int  |      | PRIMARY KEY 1 |      |         |
| from_snippet_id | int  |      |               |      |         |
| to_snippet_id   | int  |      |               |      |         |

** callgraph
Call graph of functions
| Column Name     | Type | Size | PKey          | Null | Remarks |
|-----------------+------+------+---------------+------+---------|
| ID              | int  |      | PRIMARY KEY 1 |      |         |
| from_snippet_id | int  |      |               |      |         |
| to_snippet_id   | int  |      |               |      |         |


** header_dep
The header dependence of files.
| Column Name | Type    | Size | PKey          | Null | Remarks |
|-------------+---------+------+---------------+------+---------|
| ID          | int     |      | PRIMARY KEY 1 |      |         |
| from_file   | VARCHAR |  100 |               |      |         |
| to_file     | VARCHAR |  100 |               |      |         |
